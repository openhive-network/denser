stages:
 - build
 - test
 - deploy

variables:
  # Variables required by Common CI jobs
  CI_COMMON_JOB_VERSION: "34b0315587e9fade191a927b54856d039dac9c4b"
  DOCKER_BUILDER_TAG: "$CI_COMMON_JOB_VERSION"
  DOCKER_DIND_TAG: "$CI_COMMON_JOB_VERSION"
  IMAGE_REMOVER_TAG: "$CI_COMMON_JOB_VERSION"

include:
  - template: Workflows/Branch-Pipelines.gitlab-ci.yml
  - project: 'hive/common-ci-configuration'
    ref: 34b0315587e9fade191a927b54856d039dac9c4b # develop
    file: '/templates/docker_image_jobs.gitlab-ci.yml'

docker-build:
  extends: .docker_image_builder_job_template
  stage: build
  before_script:
    - !reference [.docker_image_builder_job_template, before_script]
    - |
      echo -e "\e[0Ksection_start:$(date +%s):login[collapsed=true]\r\e[0KLogging to Docker registry..."
      docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
      echo -e "\e[0Ksection_end:$(date +%s):login\r\e[0K"
  script: 
    - |
      echo -e "\e[0Ksection_start:$(date +%s):tag[collapsed=true]\r\e[0KDetermining tag for the new image..."
      if [[ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]]; then
        echo "Running on default branch '$CI_DEFAULT_BRANCH': tag = 'latest'"
        export TAG="latest"
      else
        echo "Running on branch '$CI_COMMIT_BRANCH': tag = $CI_COMMIT_REF_SLUG"
        export TAG="$CI_COMMIT_REF_SLUG" 
      fi
      echo -e "\e[0Ksection_end:$(date +%s):tag\r\e[0K"
      echo -e "\e[0Ksection_start:$(date +%s):build[collapsed=true]\r\e[0KBaking image "$CI_REGISTRY_IMAGE:${TAG}"..."
      scripts/build_instance.sh --progress=plain "$CI_PROJECT_DIR"
      echo -e "\e[0Ksection_end:$(date +%s):build\r\e[0K"
  tags:
    - public-runner-docker

.node-job:
  image: 
    name: node:18.15-alpine3.17
    entrypoint: []
  stage: test
  script:
    - |
      echo -e "\e[0Ksection_start:$(date +%s):deps[collapsed=true]\r\e[0KInstalling dependencies..." 
      npm ci
      echo -e "\e[0Ksection_end:$(date +%s):deps\r\e[0K"
  cache:
    key: "$CI_JOB_NAME"
    paths:
      - node_modules/
      - .next/
  artifacts:
    name: "$CI_JOB_NAME-$CI_COMMIT_REF_NAME"
    when: always
    expire_in: 1 week
  tags:
    - public-runner-docker

lint:
  extends: .node-job
  script: 
    - !reference [.node-job, script]
    - |
      echo -e "\e[0Ksection_start:$(date +%s):lint[collapsed=true]\r\e[0KRunning linter..." 
      npm run lint 2>&1 | tee npm-lint.log
      echo -e "\e[0Ksection_end:$(date +%s):lint\r\e[0K"
  artifacts:
    paths:
      - "npm-lint.log"
      
publish:
  image: 
    name: node:18.15-alpine3.17
    entrypoint: []
  stage: deploy
  script:
    # Extract a few values from package.json
    - NPM_PACKAGE_NAME=$(node -p "require('./package.json').name")
    - NPM_PACKAGE_VERSION=$(node -p "require('./package.json').version")

    # Validate that the package name is properly scoped to the project's root namespace.
    # For more information, see https://docs.gitlab.com/ee/user/packages/npm_registry/#package-naming-convention
    - |
      if [[ ! $NPM_PACKAGE_NAME =~ ^@$CI_PROJECT_ROOT_NAMESPACE/ ]]; then
        echo "Invalid package scope! Packages must be scoped in the root namespace of the project, e.g. \"@${CI_PROJECT_ROOT_NAMESPACE}/${CI_PROJECT_NAME}\""
        echo 'For more information, see https://docs.gitlab.com/ee/user/packages/npm_registry/#package-naming-convention'
        exit 1
      fi

    # Compare the version in package.json to all published versions.
    # If the package.json version has not yet been published, run `npm publish`.
    - |
      if [[ "$(npm view ${NPM_PACKAGE_NAME} versions)" != *"'${NPM_PACKAGE_VERSION}'"* ]]; then
        npm publish
        echo "Successfully published version ${NPM_PACKAGE_VERSION} of ${NPM_PACKAGE_NAME} to GitLab's NPM registry: ${CI_PROJECT_URL}/-/packages"
      else
        echo "Version ${NPM_PACKAGE_VERSION} of ${NPM_PACKAGE_NAME} has already been published, so no new version has been published."
      fi
  rules:
    - if: '$CI_COMMIT_TAG && $CI_COMMIT_REF_PROTECTED == "true"'
      when: manual    
  tags:
    - public-runner-docker
